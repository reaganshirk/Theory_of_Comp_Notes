* Recognizable languages
	* Turing machine halts on "yes" instances
	* May not halt on "no" instances
	* We have Hilbert's 10th problem
	* Acceptance turing machine problem
* Co-recognizable languages
	* co is for complement
	* Turing machine halts on "no" instances
	* May not halt on "yes" instances
* Unrecognizable Languages
	* The complement of an acceptance turing machine
* Decidability
	* Objectives:
		* Explore the limits of algorithmic solvibility
		* A language is decidable only if it is recognizable
		and corecognizable at the same time
* Decidable Problems Concerning Regular Languages
	* Adfa = {<B, w> | B is a DFA accepting input string w}
		* Adfa is supposed to be A_{DFA} (A sub DFA) but I'm
		too lazy to type that out every time
	* Theorem: Adfa is a decidable language
	* Proof idea: Construct a turing machine M that decides Adfa
	M = "On input <B, w> where B is a DFA and w the input string
		* Simulate B on input w
		* If the simulation ends in an accept state, accept
		* Otherwise (M will halt always), reject
	* Anfa = {<B, w> | B is an NFA and w input}
	* Theorem: Anfa is decidable
	* Proof idea: powerset construction and use previous theorem
	* Arex = {<R, w> | R is a regular expression and w generated
	by R}
	* Theorem: Arex is decidable
	* Proof idea: Convert R into the NFA, now use the turing
	machine from the previous theorem
	* Edfa = {<A> | A is a DFA and L(A) = empty set}
	* Theorem: Edfa is decidable
	* Proof idea: Create a turing machine T that propegates
	marking labels
		* T = "On input <A> where A is a DFA
			* Mark the start state of A
			* Repeat until no new state gets marked
				* Mark any state that has incoming arrows
				from some other marked state
			* If no accept state is marked, accept
			* Otherwise, reject 
	* EQdfa = {<A, B> | A and B are DFAs such that L(A) = L(B)}
	* Theorem: EQdfa is decidable
	* Proof idea: need a DFA that accepts all of the points in
	their symmetric difference (i.e. if you draw a venn diagram
	of A and B, you want the DFA to accept all points that do
	NOT overlap)
	* Use the same proof from the last one for the DFA
	* Acfg = {<G, w> | G is a CFG and generates w}
	* Theorem: Acfg is decidable
	* Proof idea: Every CFG in chomsky normal form will generate
	in 2n-1 steps w, where |w| = n and provided that w can be
	generated by G
		* Infinitely many derivations
		* If some derivation generates w, accept
		* Otherwise, reject
* The Acceptance Problem
	* Atm = {<M, w> | M is a turing machine and M accepts w}
	* We want to show that Atm is turing recognizable 
		* Why is this true? Run M, if it accepts it accepts
	* U = "On input <M, w> where M is a turing machine and w 
	is a string
		* Simulate M on w
		* If M ever enters the accept state, accept
		* Otherwise, reject
	* Want to show that Atm is not decidable
	* Proof idea: Towards contradiction, assume that there is a 
	turing machine that decides Atm
		* Accept if M accepts w
		* reject if M does not accept w
	* Look at the following turing machine
		* D = On input <M> where M is a turing machine
			* Run H on input <M, <M>>
			* Output the opposite of whatever H returns
		* So D(<M>) will accept if H rejects <M, <M>> and will
		reject if H accepts <M, <M>>
	* What is the output of D(<D>)? 
		* D would try to reject and accept at the same time or
		something, idk. Contradiction
	* Atm is not decidable